import {
    EventEmitter2
} from 'eventemitter2';

var eventEmitterKey = 'globalEvents';
var eventEmitterCacheKey = 'globalEventsCache';
var eventEmitterCacheMaxLength = 1000;

var getCache = function(emitter) {
    var currentCache = window[eventEmitterCacheKey];
    if (isCache(currentCache)) {
        return currentCache;
    }
    var cache = [];
    // cache does not exist, so we need to bind its listener
    emitter.onAny(function(name) {
        var payload = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            payload[_i - 1] = arguments[_i];
        }
        // ensure to pop when limit is reached
        if (cache.length >= eventEmitterCacheMaxLength) {
            cache.splice(0, 1);
        }
        cache.push({
            name: name,
            payload: payload
        });
    });
    // new cache
    return cache;
};
// cache predicate will NOT guarantee all items
// are conform to cache type for performance
function isCache(obj) {
    return !!(obj && Array.isArray(obj));
}

function getEventEmitter() {
    var global = window[eventEmitterKey];
    if (isEventEmitter2(global)) {
        return global;
    }
    return new EventEmitter2({
        wildcard: true,
    });
}

function isEventEmitter2(obj) {
    return !!(obj &&
        obj.on !== undefined &&
        obj.onAny !== undefined &&
        obj.once !== undefined);
}

function integrate() {
    if (!isEventEmitter2(window[eventEmitterKey])) {
        window[eventEmitterKey] = getEventEmitter();
    }
    if (!isCache(window[eventEmitterCacheKey])) {
        window[eventEmitterCacheKey] = getCache(getEventEmitter());
    }
}

export {
    getCache,
    getEventEmitter,
    integrate
};