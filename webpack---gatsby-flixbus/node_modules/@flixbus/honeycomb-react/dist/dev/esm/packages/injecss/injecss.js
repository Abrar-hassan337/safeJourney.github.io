import React from 'react';
import baseStyles from '../../scss/honeycomb-base.js';
import {
    version
} from '../../package.js';
var CLIENT_ID_NAMESPACE = '__honeycomb-react_css_component';
var CLIENT_CLASSNAME_NAMESPACE = 'honeycomb-react-css-tag';
var CLIENT_ID_CACHE = {};
var IS_BROWSER = typeof window !== 'undefined' && typeof document !== 'undefined' && document.head; // generates style tag and appends to head with given id and css as textNode
// insert right after heads open, or right after previous sibling found, if any

var appendStyles = function appendStyles(id, css) {
    if (!document.getElementById(id)) {
        var node = document.createElement('style');
        node.textContent = css;
        node.className = CLIENT_CLASSNAME_NAMESPACE;
        node.setAttribute('type', 'text/css');
        node.id = id;
        var siblings = document.querySelectorAll(".".concat(CLIENT_CLASSNAME_NAMESPACE));

        if (siblings.length) {
            var child = siblings[siblings.length - 1];
            child.parentNode.insertBefore(node, child.nextSibling);
        } else {
            var firstChild = document.head.firstChild;
            document.head.insertBefore(node, firstChild);
        }

        return true;
    }

    return false;
}; // helper to generate inline style tag and cache css
// returns null when no context is provided


var cachedInlineCss = function cachedInlineCss(cache, styles, id) {
    if (!cache[id]) {
        // eslint-disable-next-line no-param-reassign
        cache[id] = true; // eslint-disable-next-line no-param-reassign

        if (!cache.styles) cache.styles = ''; // eslint-disable-next-line no-param-reassign

        cache.styles += styles;
    }

    return null;
}; // Context for server side rendering


var InjecssContext = React.createContext({}); // decorator factory

var Injecss = function Injecss(component) {
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        styles = _ref.raw; // actual decorator


    var decorator = function decorator(Comp) {
        return function(props) {
            // using displayName and namespace string as unique ID for caching,
            // this ensures every honeycomb component has unique cache ID
            var componentID = Comp.displayName + CLIENT_ID_NAMESPACE + version.replace(/\./g, '-'); // if no css or empty object return component

            if (typeof styles === 'undefined') {
                return /*#__PURE__*/ React.createElement(Comp, props);
            } // Add base styles, once


            var baseStylesId = "base-styles".concat(CLIENT_ID_NAMESPACE);

            if (!CLIENT_ID_CACHE[baseStylesId] && IS_BROWSER) {
                appendStyles(baseStylesId, baseStyles.raw);
                CLIENT_ID_CACHE[baseStylesId] = true;
            } // append cache to head if client and not cached


            if (!CLIENT_ID_CACHE[componentID] && IS_BROWSER) {
                if (appendStyles(componentID, styles)) {
                    // set to true if styles were appended successfully
                    CLIENT_ID_CACHE[componentID] = true;
                }
            } // server rendered component


            return /*#__PURE__*/ React.createElement(React.Fragment, null, /*#__PURE__*/ React.createElement(Comp, props), /*#__PURE__*/ React.createElement(InjecssContext.Consumer, null, function(value) {
                return cachedInlineCss(value, styles, componentID);
            }));
        };
    }; // create the component


    var comp = decorator(component); // assign it a name

    comp.displayName = "Injecss(".concat(component.displayName, ")"); // ship it

    return comp;
};

export {
    Injecss,
    InjecssContext
};